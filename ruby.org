* 前言部分
#+BEGIN_LaTeX
\newpage
#+END_LaTeX
** 松本行弘的程序世界

    本书为“Ruby”之父经典力作，展现了大师级的程序思考方式。作者凭借对编程本质的
    深刻认识和对各种技术优缺点的掌握，阐述了Ruby的设计理念，并由此延伸，带领读者
    了解编程的本质，一窥程序设计的奥秘。
    本书不是为了介绍某种特定的技术，而是从宏观的角度讨论与编程相关的各种技术。书
    中第1章介绍了作者对编程问题的新思考和新看法，剩下的内容出处《日经Linux》杂志
    于2005年5月到2009年4月连载的“松本编程模式讲坛”，其中真正涉及“模式”的内容
    并不多，大量篇幅都用于介绍技术内幕和背景分析等内容，使读者真正了解相关技术的
    立足点。另外，书中还包含许多以Ruby、Lisp、Smalltalk、Erlang、JavaScript等动
    态语言所写成的范例。

- Ruby之父佳作，进入不同凡响的程序世界
- 深入剖析程序设计的道与术
- 举一反三，触类旁通
#+BEGIN_LaTeX
\newpage
#+END_LaTeX
**  内容提要

本书是探索程序设计思想和方法的经典之作。作者从全局的角度，利用大量的程序示例及图
表，深刻阐述了Rub 编程语言的设计理念，并以独特的视角考察了与编程相关的各种技术。
阅读本书不仅可以深入了解编程领域各个要素之间的关系，而且能够学到大师的思考方法。
本书面向各层次程序设计人员和编程爱好者，也可以供相关技术人员参考。

#+BEGIN_LaTeX
\newpage
#+END_LaTeX

** 推荐序

在流行的编程语言中，Ruby 比较另类，这是因为大多数编程语言的首要着眼点在于为解决
特定的问题领域而设计语言，而Ruby的首要着眼点在于“人性化”，让程序员充分享受编程
的乐趣。由于组织国内的Ruby会议，我曾两次邀请松本行弘来中国。他是一位性格平和、对
生活充满热爱的人，在演讲吕也一再传递code for fun的宗旨，即编程语言不应该是冷冰冰
地给机器阅读的执行的指令，而应该昌让程序员编程的工作过程变成一种充满乐趣和享受的
过程。而且，松本先生发明Ruby语言也是因为他对创造一种人性化的面向对象脚本语言的热
爱。

程序员社区经常拿另外一个主流的面向对象脚本语言Python 来和 Ruby 做对比。从全球范
围来看，Python 的社区更大，应用更广泛，但Ruby的语法相对Python来说更强大和宽松，
给程序员发挥的自由度更大，可以基于Ruby创建各个领域的DSL,比方说Ruby on Rails就是
一个基于Ruby的Web快速开发领域的DSL。

总之，Ruby 语言的这种“人性化”以及给程序员很大编程自由度的气质奠定了整个Ruby社
区的气质：热爱生活的程序员，所求编程的自由度，带点非主流的极客色彩。也下因为如此，
Ruby和基于Ruby的Rails得到了硅谷许许多多创业公司青睐，有名者如Twitter、Groupon、
Hulu、github等。而这种气质也鲜明地体现在Rails框架的创建者David Heinemeier
Hansson及其所在的37signals公司身上。37signals的20多位员工遍全球，每天只上班四天，
David Heinemeier Hansson 本人不是一位保时捷车队的职业赛车手。

当然，Ruby并非只在非主流程序员社区中流行，随着全球IT产业进行云计算时代，Ruby也发
挥着越来越大的作用。著名的SAAS厂商salesforce 在2010年底以2.1亿美元收购了PAAS厂商
Heroku,并且在2011年7月聘请松本行担任Heroku首席架构师，开拓Ruby在云计算领域的应用。
Heroku 本身就是一个完全采用Ruby架构的PAAS平台，同样支持Ruby的PAAS厂商还有
EngineYard、VMware等。随着这些云计算厂商的努力，Ruby必然在未来得到越来越广泛的应
用。
我之前阅读了本书的部分章节，这本书实际上是松本行弘从一个编程语言设计者的角度去看
待各种各样的流行编程语言，分析它们有哪些特点，以及Ruby编程语言是如何取舍的。Ruby
语言的设计本身大量参考了一个更古老而著名的面向对象编程方法的开山之作Smalltalk,而
且从函数式编程语言鼻祖Lisp“偷师学艺”了不少好东西。程序员社区有个著名的说法：任
何现代编程语言都脱胎于Smalltalk 和Lisp,都与这两个编程语言有着似曾相识的特性，自
Smalltalk和Lisp诞生以来，编程语言领域可谓大势已定了。因此，集这两种编程语言诸多
特点于一身的Ruby语言很值得编程爱好者去学习，而看看Ruby设计师是怎么设计Ruby语言的，
则可以让人高屋建领地理解一些主流的编程语言。

                 范凯
#+BEGIN_LaTeX
\newpage
#+END_LaTeX

** 中文版序

从年轻的时候开始，我就对编程语言有着极为浓厚的兴趣。比起“使用计算机干什么”这一
问题，我总是一门心思想着“如何将自己的意图传达给计算机”。从这个意义上说，我认为
自己是个“怪人”。但是，想选择一个能让自己的工作变得轻松的编程语言，想编写一种让
人用起来感到快乐的编程语言，一直是我梦寐以求的，这种迫切的心情怕不输于任何人。虽
说是有点自卖自夸，但是Ruby确实给我带来了“快乐”，这一结果让我感到很满足。

让我感到惊奇的是，有很多人，包括那些没有我这么“怪”的人，都对这种快乐有着共鸣。
Ruby自1995年在互联网上公布以来，着实让世界各地的程序员都认识了它，共享着这种快乐，
提高了软件开发的生产力。完全出乎我意料的是，世界各地的人，不管是东方还是西方，都
极为欣赏Ruby。在刚开始开发Ruby的时候，我想都没有想到过有这样的结果，程序员的感觉
会超越人种、国籍、文化，有如此之多的共通之处。

现在，为世界各地的程序员所广泛接受的Ruby，正带来一种新的文化。已经有越来越多的开
发人员，在实践中果敢地施行着Ruby语言及其社区所追求的“对高生产力的追求”、“富有
柔性的软件开发”、“对程序员人性的尊重”、“鼓起勇气挑战新技术”等原则。在Ruby以
前，这些想法也都很好，却一直实践不起来。我相信，Ruby的卓越之处，不仅在于语言能力，
而且更重要的是引领了这种文化的践行。

本书在解说编程中的技术与原则时，不局限于表面现象，而是努力挖掘其历史根源，提示其
本质。虽然很多章节都以Ruby为题材，但这些原则对于Ruby以外的语言也行之有效。衷心希
望大家能够实践本书中所讲述的各项原则，成为一个更好的开发人员。

      松本行弘

2011年4月18日
#+BEGIN_LaTeX
\newpage
#+END_LaTeX

**  DONE 前言<2016-08-30 二 14:10>
  CLOSED: [2016-08-30 二 15:30]
  :LOGBOOK:
  - State "DONE"       from "STARTED"    [2016-08-30 二 15:30]
  CLOCK: [2016-08-30 二 14:10]--[2016-08-30 二 15:30] =>  1:20
  :END:

本书的目的不是深入讲解哪种特定的技术，也没有全面讨论我所开发的编程语言Ruby，而是
从全局角度考察了与编程相关的各种技术。读者千万不要以为拿着这本书，就可以按图索骥
地解决实际问题了。实际上，最好反它看成是一幅粗略勾勒出了编程世界诸要素之间关系的
“世界地图”。

每种技术、思想都有其特定的目的、渊源和发展进步的过程。本书试图换一个角度重新考察
各种技术。如果你看过后能够感觉到“啊，原来是这样的呀!”或者“噢，原来这个技术的
立足点在这里呀!”那么我就深感心慰了。我的愿望就是这些知识能够激发读者学习新技术
的求知欲。

本书的第2章到第14章，是在《日经Linux》杂志于2005年5月到2009年4月连载的“松本编程
模式讲坛”基础上编辑修改而成的。但实际上连载与最开始的设想并不一致，真正涉及“模
式”的内容并不多，倒是技术内幕、背景分析等内容占了主流。现在想来，大方向并没有错。

除了连载的内容之外，本书还记录了我对编程问题的新思考和新看法。特别是第1章“我为
什么开发Ruby”，针对“为什么是Ruby”这一点，比其他杂志做了更加深入的解说。另外，
在每章的末尾增加了一个小专栏。

对于连载的内容，因为要出成一本书，除修改了明显的错误和不合时代的部分内容之外，我
力求每一章都独成一体、内容完整，同时也保留了连载时的风貌。通读全书，读者也许会感
到有些话题或讲解是重复的，这一点敬请原谅。

我的本职工作是程序员，不能集中大段时间去写书，不过无论如何最后总算是赶出来了。非
常感谢我的家人，她们在这么长时间里宽容着我这个情绪不稳的丈夫和父亲。

稿子写完了，书也出来了，想着总算告一段落了吧，而《日经Linux》又要开始连载“松本
行弘技术剖析”了，恐怕还要继续让家里人劳心。

松本行弘

2009年4月于樱花季节过后的松江


* DONE 第一章 我为什么开发Ruby
  CLOSED: [2016-09-01 Thu 17:27]
  :LOGBOOK:
  - State "DONE"       from "STARTED"    [2016-09-01 Thu 17:27]
  CLOCK: [2016-09-01 Thu 14:30]--[2016-09-01 Thu 17:27] =>  2:57
  :END:

** 1.1 我为什么开发Ruby

 Ruby是起源于日本的编程语言。近年来，特别是因为其在Web开发方面的效率很高,Ruby引起
 了全世界的关注，它的应用范围也扩展到了很多企业领域。

 作为一门编程语言，Ruby正在被越来越多的人所了解，而作为一介工程师的我，松本行弘，
 刚开始的时候并没有想过“让全世界的人都来用它”或者“这下子可以大赚一笔了”，一个
 仅仅是从兴趣开始的项目却在不知不觉中发展成了如今的样子。

 当然了，那时开发Ruby并不是我的本职工作，纯属个人兴趣，我是把它作为一个自由软件来
 开发的。但是世事弄人，现在开发Ruby竟然变成了我的本职工作了，想想也有些不可思议。

 “你为什么开发Ruby？” 每当有人这样问我的时候，我认为最合适的回答应该就像Linux的
 开发者Linus Torvalds对“为什么开发Linux”的回答一样吧———

 “因为它给我带来了快乐。”

 当我还是一个高中生，刚刚开始学习编程的时候，不知何故，就对编程语言产生了兴趣。

 周围很多喜欢计算机的人，[fn:no.1]有的是“想开发游戏”，有的是“想用它来做计算”，等等，都
 是“想用计算机来做些什么”。而我呢，则想弄明白“要用什么编程语言来开发”、“用什
 么语言开发更快乐”。

 高中的时候，我自己并不具备开发一种编程语言所必需的技术知识，而且当时也没有计算机。
 但是，我看了很多编程语言类的书籍和杂志，知道了“还有像Lisp这样优秀的编程语言”、
 “Smalltalk是做面向对象设计的”，等等，在这些方面我很着迷。上大学时就自然而然地
 选修了计算机语言专业。10年后，我通过开发Ruby实现了自己的梦想。

 从1993年开发Ruby到现在已经过去16年了。在这么久的时间里，我从未因为设计Ruby而感到
 厌烦。开发编程语言真是一件非常有意思的事情。

*** 1.1.1 编程语言的重要性

  为什么会喜欢编程语言？我自己也说不清。至少，我知道编程语言是非常重要的。

  最根本的理由是：语言体现了人类思考的本质。在地球上，没有任何超越人类智慧的生物，
  也只有人类能够使用语言。所以，正是因为语言，才造成了人类和别的生物的区别；正是因
  为语言，人和人之间才能传递知识和交流思想，才能做深入的思考。如果没有了语言人类和
  别的动物也就不会有太大的区别了。

  在语言领域里，有一个Sapir-Whirf假说，认为语言可以影响说话者的思想。也就是说，语
  言的不同，造成了思想的不同。人类的自然语言是不是像这个假说一样，我不是很清楚，但
  是我觉得计算机语言很符合这个假说。也就是说，程序员由于使用的编程语言不同，他的思
  考方法和编写出来的代码都会受到编程语言的很大影响。

  也可以这么说，如果我们选择了好的编程语言，那么成为好程序员的可能性就会大很多。

  20年来一直被奉为名著的《人月神话》的作者Frederick. Brooks说过：一个程序员，不管
  他使用什么编程语言，他在一定时间里编写的程序行数是一定的。如果真是这样，一个程序
  员一天可以写500行程序，那么不论他用汇编、C,不是Ruby，他一天都应该可以写500行程序。

  但是，汇编的500行程序和Ruby的500行程序所能做的事情是有天壤之别的。程序员根据所选
  择编程语言的不同，他的开发效率就会有十倍、百倍甚至上千倍的差别。

  由于价格降低、性能提高，计算机已经很普及了。现在基本上各个领域都使用了计算机，但
  如果没有软件，那么计算机这个盒子恐怕一点用都没有了。而软件开发，就是求能够用更少
  的成本、更短的时间，开发出更多的软件。

  需要开发的软件越来越多，开发成本却有限，所以对于开发效率的要求就很高。编程语言就
  成了解决这个矛盾的重要工具。

*** 1.1.2 Ruby的原则

  Ruby本来是我因兴趣开发的。因为对多种编程语言都很感兴趣，我广泛对比了各种编程语言，
  哪些特性好，哪些特性没什么用，等等，通过一一进行比较、选择，最终把一些好的特性吸
  纳进了Ruby编程语言之中。

  如果什么特性都不假思索地吸纳，那么这种编程语言只会变成以往编程语言的翻版，从而失
  去了它作为一种新编程语言的存在价值。

  编程语言的设计是很困难的，需要仔细斟酌。值得高兴的是，Ruby的设计很成功，很多人都
  对Ruby给出了很好的评价。

  那么，Ruby编程语言的设计原则是什么呢？

  Ruby编程语言的设计目标是，让作为语言设计者的我能够轻松编程，进而提高开发效率。

  根据这个目标，我制订了以下3个设计原则。

  - 简洁性
  - 扩展性
  - 稳定性

  关于这些原则，下面分别加以说明。

*** 1.1.3 简洁性

  以Lisp编程语言为基础而开发的商业软件Viaweb被Yahoo收购后，Viaweb的作者PaulGraham
  也成了大富豪。最近他又成了知名的技术专栏作家，写了一篇文章就叫“简洁就是力量”。[fn:no2]

  他还撰写了很多倡导Lisp编程语言的文章。在这些文章中他提到，编程语言在这半个世纪以
  来是向着简洁化的方向发展的，从程序的简洁程度就可以看出一门编程语言本身的能力。上
  面提到的Brooks也持同样的观点。

  随着编程语言的演进，程序员已经可以更简单、更抽象地编程了，这是很大的进步。另外随
  着计算机性能的提高，以前在编程语言里实现不了的功能，现在也可以做到了。

  面向对象编程就是这样的例子。面向对象的思想只是把数据和方法看作一个整体，当作对象
  来处理，并没有解决以前解决不了的问题。

  用面向对象记述的算法也一定可以用非面向对象的方法来实现。而且，面向对象的方法并没
  有实现任何新的东西，却要在运行时判定要调用的方法，倾向于增大程序的运行开销。即使
  是实现同样的算法，面向对象和程序往往更慢，过去计算机的执行速度不够快，很难请允许
  我像这样的“浪费”。

  而现在，由于计算机性能大大提高，只要可以提高软件开发效率，浪费一些计算机资源也无
  所谓了。

  再举一些例子。比如内存管理，不用的内存现在可用垃圾收集器自动释放，而不用程序员自
  己去释放了。变量和表达式的类型检查，在执行时已经可以自动检查，而不用在编译时检查
  了。

  我们看一个关于斐那契（Fibonacci）数的例子。图1-1所示为用Jave程序来计算斐波那契数。
  算法有很多种，我们最常用的递归算法来实现。

  图1-2所示为完全一样的实现方法，它是用Ruby编程语言写的，算法完全一样。和Java程序
  相比，可以看到构造完全一样，但是程序更简洁。Ruby 不进行明确的数据类型定义，不必
  要的声明都可以省略。所以，程序就非常简洁了。
  #+BEGIN_SRC org
  class Sample {
   private static int fib (int n){
     if (n<2){
         return n;
      }
      else {
           return fib (n-2) +fib (n-1);
          }
    }
    public static void main(String[]argv){
      System.out.println("bib(6)-"+fib(6));
   }
  }
  #+END_SRC
  图1-1 计算斐波那契数的Java程序
  #+BEGIN_SRC org

  def fib(n)
    if n<2
     n
    else
      fib(n-2) +fib(n-1)
    end
  end
  print "fib(6)=",fib(6),"\n"
  #+END_SRC
  图1-2 计算斐波那契数的Ruby程序

  算法的教科书总是用伪码来描述算法。如果像这样用实际的编程语言来描述算法，那么像类
  型定义这样的非实质代码就会占很多行，让人不能专心于算法。
  如果可以反伪码中非实质的东西去掉，只保留描述算法的部分就直接运行，那么这种编程语
  言不就是最好的吗？ Ruby的目标就是成为开发效率高、“能直接运行的伪码式语言”。

*** 1.1.4 扩展性

下一个设计原则是“扩展性”。编程语言作为软件开发工具，其最大的特征就是对要实现的
功能事先没有限制。“如果想做就可以做到”，这听起来像小孩子说的话，但在编程语言的
世界里，真的就是这么一回事。不管在什么领域，做什么处理，只要用一种编程语言编写出
了程序，我们就可以说这种编程语言适用于这一领域。而且，涉及领域之广远远超出我们当
初要预想。

1999年，关于Ruby的第一本书《面向对象脚本语言Ruby》出版的时候，我在里面写道，
“Ruby 不适合的领域”包括“以数值计算为主的程序”和“数万行的大型程序”。

但在几年后，规模达几万行、几十万行的Ruby程序被开发出来了。气象数据分析，乃至生物
领域中也用到了Ruby。现在，美国国家海洋和航天局（NOAA,National Oceanic and
Atmospheric Administration)、美国国家航空和航天局（NASA，National Aeronautice
and Space Administration)也在不同的系统中运用了Ruby。

情况就是这样，编程语言开发者事先并不知道这种编程语言会用来开发什么，会在哪些领域
中应用。所以，编程语言的扩展性非常重要。

实现扩展性的一个重要方法是抽象化。抽象化是指把数据和要做的处理封装起来，就像一个
黑盒子，我们不知道它的内部是怎么实现的，但是可以用它。

以前的编程语言在抽象化方面是很弱的，要做什么处理首先要了解很多编程语言的细节。而
很多面向对象或者函数式的现代编程语言，都在抽象化方面做得很好。

Ruby也不例外。Ruby从刚开始设计时就用了面向对象的设计方法，数据和处理的抽象化提高
了它的开发效率。我在1993年设计Ruby时，在脚本编程语言中采用面向对象思想的还很少，
用类库方式来提供编程语言的就更少了。所以现在Ruby的成功，说明当时采用面向对象方法
的判断是正确的。

Ruby的扩展性不仅仅体现在这些方面。

比如Ruby以程序块这种明白易懂的形式给程序员提供了相当于Lisp高阶函数的特性，使“普
通的程序员”也能够通过自定义来实现控制结构的高阶函数扩展。又比如已有类的扩展特性，
虽然有一定的危险性，但是程序却可以非常灵活地扩展。关于这些面向对象、程序块、类扩
展特性的内容，后面的章节还会详细介绍。

这些特性的共同特点是，它们都表明了编程语言让程序员最大限度地获得了扩展能力。编程
语言不是从安全角度考虑以减少程序员犯错误，而是在程序员自己负责的前提下为他提供最
大限度发挥能力的灵活性。我作为Ruby的设计者，也是Ruby的最初用户，从这种设计的结果
可以看出，Ruby看重的不是明哲保身，而是如何最大限度地发挥程序员自身的能力。

关于扩展性，有一点是不能忽视的，即“不要因为想当然而加入无谓的限制”。比如说，刚
开始开发Unicode时，开发者想当然地认为16们（65535个字符）就足够容纳世界上所有的文
字了；同样，Y2K问题也是因为想当然地认为用2位数表示日期就够了才导致的。从某种角度
说，编程的历史就是因为想当然而失败的历史。而Ruby对整数范围不做任何限定，尽最大努
力排除“想当然”。

*** 1.1.5 稳定性

虽然Ruby非常重视扩展性，但是有一个特性，尽管明知道它能带来巨大的扩展性，我却一直
将其拒之门外。那就是宏，特别是Lisp风格的宏。

宏可以替换掉原有的程序，给原有的程序加入新的功能。如果有了宏，不管的控制结构，还
是赋值，都可以随心所欲的进行扩展。事实上，Lisp编程语言提供的控制结构很大一部分都
是用宏来定义的。

所谓Lisp流，其语言核心部分仅仅提供极为有限的特性和构造，其余的控制结构都是在编译
时通过用宏来组装其核心特性来实现的。这也就意味着，由于有了这种无与伦比的扩展性，
只要掌握了Lisp基本语法S式（从本质上讲就是括号表达式），就可以开发出千奇百怪的语
言。Common Lisp 的读取宏提供了在读取S式的同时进行语法变换的功能，这就在实际上摆
脱了S式的束缚，任何语法的语言都可以用Lisp来实现。

那么，我为什么拒绝在Ruby中引入LIsp那样的宏呢？ 这是因为，如果在编程语言中引入宏
的话，活用宏的程序就会像是用完全不同的专用编程语言写出来的一样。比如说Lisp就经常
有这样的现象，活用宏编写的程序A和程序B，只有很少一部分昌共通的，从语法到词汇都各
不相同，完全像是用不同的编程语言写的。

对程序员来说，程序的开发效率固然很重要，但是写出的程序是否具有很高的可读性也非常
重要。从整体来看，程序员读程序的时间可能比写程序的时间还长。读程序包括为理解程序
的功能去读，或者是为维护程序去读，或者是为调试程序去读。

编程语言的语法是解读程序的路标。也就是说，我们可以不用追究程序或库提供的类和方法
的详细功能，但是，“这里调用了函数”、“这里有判断分支”等基本的“常识”在我们读
程序时很重要。

可是一旦引入了宏定义，这一常识就不再适用了。看起来像是方法调用，而实际上可能是控
制结构，也可能是赋值，也可能有非常严重的副作用，这就需要我们去查阅每个函数的方法
的文档，解读程序就会变得相当困难。

当然了，我知道世界上有很多Lisp程序员并不受此之累，他们只是极少数的一部分程序员。

我相信，作为在世界上广泛使用的编程语言，应该有稳定的语法，不能像随风飘荡的灯芯那
样闪烁不定。

*** 1.1.6 一切皆因兴趣

当然，Ruby不是世界上唯一的编程语言，也不能说它是最好的编程语言。各种各样的编程语
言可以在不同的领域吕应用，各有所长。我自己以及其他Ruby程序员，用Ruby开发很高，所
以觉得Ruby“最为得心应手”。当然，用惯了Python或者Lisp的程序员，也会觉得那些编程
语言是最好的。

不管怎么说，编程语言存在的目的是让人用它来开发程序，并且尽量能提高开发效率。这样
的话，才能让人在开发中体会到编程的乐趣。

我在海外讲演的时候，和很多人交流过使用Ruby的感想，比较有代表性的是：“用Ruby开发
很快乐，谢谢!”

是啊，程序开发本来就是一件很快乐、很刺激和很有创造性的事情。想起中学的时候，用功
能不强的BASIC编程语言开发，当时也是很快乐的。当然，工作中会有很多的限制和困难，
编程也并不都是一直快乐的，这也是世之常情。

Ruby能够提供很高的开发效率，让我们在工作中摆脱很多困难和烦恼，这也是我开发Ruby的
目的之一吧。

* 第二章 面向对象

** 2.1 编程和面向对象的关系

所谓编程，就是把工作的方法告诉计算机。但是，计算机是没有思想的，它只会简单地按照
我们说的去做。计算机看起来功能很强大，其实它也仅仅只会做高速计算而已。如果告诉它
效率很低的方法，它也只是简单机械地去执行。所以，到底是最大程序地发挥计算机的能力，
不是扼杀它的能力，都取决于我们编写的程序了。

程序员让计算机完全按照自己的意志行事，可以说是计算机的“主宰”。话虽如此，但世人
多认为程序员是在为计算机工作。

不，不只是一般人，很多计算机业内人士也是这样认为的，甚至比例更高。难道因为是工作，
所以就无可奈何了吗？

*** 2.1.1 颠倒的构造

 如果仔细想想，就会感到很不可思议。为什么程序员非要像计算机的奴隶一样工作呢？ 我
 们到底是从什么时候放弃主宰计算机这个念头的呢？

我想，其中的一个原因是“阿尔法综合征”。阿尔法综合征是指在饲养宠物狗的时候，宠物
狗误解了一直细心照顾它的评价的地位，反而感觉到它自己是主人，比主人更了不起。

计算机也不是好伺候的。系统设计困难重重，程序有时也会有错误。一旦有规格变更，程序
员就要动手改程序，程序有了错误，也需要一个个纠正过来。

所以在诸如此类烦琐的工作中，就会发生所谓的“逆阿尔法综合征”现象，主从关系颠倒，
话务员沦为“计算机的奴隶”，说的客气一些，也顶多能算是“计算机的看门狗”。难道这
是人性使然？

不，不要轻易放弃。人是万物之灵，比计算机那玩意儿要聪明百倍，当然应该摆脱计算机奴
隶的地位，把工作都推给机器来干，自己尽情享受轻松自在。因此，我们的目标就是让程序
员夺回主动权！

程序员如果能够充分利用好计算机所具有的高速计算能力和信息处理能力，有可能会从奴隶
摇身一变，“像变戏法一样”完成工作，实现翻天覆地的大逆转。

但是，要想赢得这场夺回主动权的战争，“武器”是必须的。那就是本书是讲解的“语言”
和“技术”。

Ruby 的安装

读者中恐怕有不少人的初次安装Ruby，所以这里再介绍一下Ruby的安装方法。我在写这本书
的时候，Ruby的版本是1.9.1。在我平时使用的Debian GNU/Linux操作系统中，用下面的方
法来安装Ruby。

$ apt-get install ruby

其他的Linux操作系统大多也提供了Ruby的开发包。

在Windows操作系统中安装Ruby时，直接点击安装文件就可以了。从下面的网站可以下载安
装程序：http://rubyinstaller.rubyforge.org。

如果从Ruby源程序来编译安装的话，可以从下面的网站来下载Ruby源程序包
（tarball):http://ruby-lang.org。

编译和安装的方法如下。

$ tar zxvf ruby-1.9.1-p0.tar.gz

$ cd ruby-1.9.1-p0

$ ./configure

$ make

$ su

$ make install

*** 2.1.2 主宰计算机的武器

程序员或者将要成为程序员的人，如果成了计算机的奴隶，那是十分不幸的。为了能够主宰
计算机，必须以计算机的特性和编程语言作为武器。

编程语言是描述程序的方法。目前有很多种编程语言，有名的有BASIC、FORTRAN、C、C++、
Java、Perl、PHP、Python、Ruby等。

从数学的角度来看，几乎所有的编程语言都具备“图灵完备”[fn:no3]的属性，无论何种编程语言都
可以记述等价的程序，但这并不是说选择什么样的编程语言都一样。每种编程语言都有自己
的特征、属性，都各有长处和短处、适合的领域和不适合的领域。写程序的难易程度（生产
力）也有很大的不同。

有研究表明，开发程序时用的编程语言和生产力并没有关系，不论用什么编程语言，一定时
间内程序的开发规模（在一定程度上）是相当的。
还有一些研究表明，为了完成同样的任务，程序规模会因为开发时选取的编程语言和库而相
差数百倍，甚至数千倍。所以如果选用了合适的编程语言，那么你的能力就可能增长数千倍。

但是不论什么都是有代价的。比如效率高的开发环境，在执行时效率往往很低。还有很多领
域需要人们想尽办法去提高速度。在这里，因为我们在讨论如何主宰计算机，所以尽可能地
选择让人们轻松的编程语言。基于这个观点，本书用Ruby语言来讲解。当然，Ruby是我设计
的，讲解起来相对也就容易点。

Ruby是面向对象的编程语言，具有简洁和一致性。开发Ruby的宗旨是用它可以轻松编程。


Ruby的运行环境多种多样，包括Linux及UNIX系列操作系统、Windows、MacOS X等各种平台，
很多系统上都有Ruby的软件包[fn:1]。当然，如果有C编译器，也可以从源程序来安装Ruby。

*** 2.1.3 怎样写程序

使用编程语言写好程序是有技巧的。在本书中，将会介绍表2-1中列出的编程技巧。

表中的编程风格指的是编程的细节，比如变量名的选择方法、函数的写法等。

算法是解决问题的方法。现实中各种算法都已经广为人知了，所以编程时的算法也就是对这
些技巧的具体应用。

有很多算法如果单靠自己去想是很想出来的。比方说数组的排序就有很多的算法，如果我们
对这些算法根本就不了解，那么要想做出调整排序程序会很困难。算法和特定的数据结构关
系很大。所以有一位计算机先驱曾经说过：“程序就是算法回味数据结构”。[fn:a2]

设计模式是指设计软件时，根据以前的设计经验对设计方法进行分类。算法和数据结构从广
义上来说也是设计模式的一种分类。有名的分类（设计模式）有23种[fn:a3]。

开发方法是指开发程序时的设计方法，指包括项目管理在内的整个程序开发工程。小的软件
项目可能不是很明显，在大的软件项目中，随着开发人员的增加，整个软件工程的开发方法
就很重要。

*** 2.1.3 面向对象的编程方法

下面，我们来看看Ruby的基本原理————面向对象的设计方法。面向对象的设计方法是20世纪
60年代后期，在诞生于瑞典的Simula编程语言中最早开始使用的。Simula作为一种模拟语言，
对于模拟的物体，引入了对象这种概念。比如说对于交通系统的模拟，车和信号就变成了对
象。一辆辆车和一个个信号就是一个个对象，而用来定义这些车和信号的，就是类。

此后，从20世纪70年代到80年代前期，美国施乐公司的帕洛阿尔托研究中心（PARC)开发了
Smalltalk编程语言。从Smalltalk-72、Smalltalk-78 到 Smalltalk-80，他们开发完成了
整个Smalltalk系列。Smalltalk编程语言对近代面向对象编程语言影响很大，所以把它称为
面向对象编程语言之母也不为过。

在这之后，受 Simula影响比较大的有C++编程语言，再以后还有Jave编程语言，而现在大多
数编程语言使用的教师面向对象的设计方法。

*** 2.1.5 面向对象的难点

面向对象的难点在于，虽然有关于面向对象的说明和例子，但是面向对象具体的实现方法却
不是很明确。

面向对象这个词本身是很抽象的，越抽象的东西，人们就越难理解。并且对于面向对象这个
概念，如果没有严密的定义，不同的人就会有不同的理解。

这里，我们暂时回避一下“面向对象”的整体概念这一问题，首先集中说明“面向对象编
程”。

至于“好像是听明白了，还是不会使”这一点，原因可能在于平易的比喻和实际编程之间差
距太大。这里，我们选择Ruby这种简单易用的面向对象编程语言，希望能够拉近比喻和实例
之间的距离。

另外很重要的一点，面向对象编程语言有很多种类，也有很多技巧。一下子全部理解是很多
困难的，我们分别加以说明。

我认为面向对象编程语言中最重要的技术是“多态性”。我们就先从多态性说起吧。

*** 2.1.6 多态性                                                     :secret:

多态性，英文是polymorphism，其中词头poly-表示复数，morph表示形态，加上词尾-ism,
就是复数形态的意思，我们称它为多态性。

换个说法，多态就是可以把不同种类的东西做相同的东西来处理。

只从字面上分析不容易理解，举例说明一下。

看看图2-1所示的3个箱子。每个箱子都有不同的盖子。一个是一般的盖子，一个是带锁的盖
子，一个是带有彩带的盖子。因为箱子本身非常昂贵，所以每个箱子都有专人管理，如果要
从箱子里取东西，要由管理人员去做。

打开3个箱子的方法都不同，但如果发出同样的打开箱子的命令，3 个人会用自己的方法来
打开自己的箱子。因此，3 个箱子虽然各有不同，但它们同样“都是箱子，可以打开盖子”。
这就是多态性的本质。

在编程中，“打开箱子”的命令，我们称之为消息；而打开不同箱子的具体操作，我们称之
为方法。

*** 2.1.7 具体的程序

上面例子的程序如图2-2所示。

box_open 是打开箱子的方法，相当于前面所说的“管理员”。调用box_open这个方法时，
方法会根据参数（箱子和种类）的不同做相应的处理。你只要说“打开箱子”，箱子就真地
被打开了。这种“根据对象不同类型而进行适当地处理”就是多态性的基本内容。

但只有图2-2还不够。我们来考虑一下如何定义box_open 这个方法吧。如果只是单纯地实现
这个方法，也许就会写成图2-3的样子。

但是，图2-3所示的处理并不能令人满意。如果要增加箱子种类，这个方法中的代码就要重
写，而且如果还有其他类似于 box_open 、需要根据箱子类型来做不同的处理的方法，那么
需要修改的地方就越来越多，追加箱子种类就会变得非常困难。

程序修改得越多，出错的可能性也就越大，结果可能是程序本身根本就动不起来了。

像这样的修改本来就不该直接由人来做。根据数据类型来进行合适的处理（调用合适的方
法），本来就应该是编程语言这种工具应该完成的事。只有实现了这一点，才能称为真正的
多态。

为此，我们修改一下图2-2的程序，来看看真正的多态是如何工作的。

图2-4的程序把参数移到了前头，并增加了一个“.”。这行代码可以理解为“给前面式子的
值发送 open 消息”。也就是说，它会“根据前面式子的值，调用合适的 open 方法”。这
就是利用了多态性的调用方法。

图2-4程序中的各种处理方法的定义如图2-5所示。

图2-5的程序定义了3种箱子：box1、box2、box3，表示“打开箱子”的不同方法。

比较图2-5和图2-3的程序可以看到，程序中不再有直白的条件判断，非常简明了。即使在图
2-5中程序增加一种新的箱子，比如“横向滑动之后打开箱子”，也不需要对原来的程序做
任何修改。不需要修改，当然也就没有因修改而出错的危险。

图2-2 例子的程序
 #+BEGIN_SRC org

 # 用变量 box1 box2 box3 代表3个箱子

box_open(box1) # 表示打开箱子
box_open(box2) # 表示开锁，打开箱子
box_open(box3) # 表示解开彩带，打开箱子

  #+END_SRC

图2-3 图2-2例子的box-open 方法的内容

#+BEGIN_SRC org
def box_open(box)

# 判断 box 类型的方法
if box_type(box)=="plain"
  puts("打开箱子")
elsif box_type(box)=="lock"
 puts("开锁,打开箱子")
elsif box_type(box)=="ribbon"
 puts("解开彩带，打开箱子")
else
 puts("不知道打开箱子的方法")
end

end
#+END_SRC

*** 2.1.8 多态性的优点

前面说明了多态性，那么它到底有什么好处呢？

首先，各种数据可以统一地处理。多态性可以让程序只关注要处理什么（What），而不是怎
么去处理（How）。

其次，是根据对象的不同自动选择最合适的方法，而程序内部则不发生冲突。不管调用有锁
的箱子，还是系着彩带的箱子，它们都能自动处理，不用担心调用中会发生错误，这样就会
减轻程序员的负担。

再次，如果有新数据需要对应处理的话，通过简单的追加就可以实现了。而不需要改动以前
的程序，这就让程序具备了扩展性。

综上所述，多态性提高了开发效率，所以说，面向对象技术最重要的一个概念应该是多态性。

-----

*相关的Ruby语法*

为了让读者能理解本书中的程序例子，这里简单说明一下Ruby语法。

首先，以"#"开始的行是注释行，注释的内容随便是什么都可以。



#+BEGIN_SRC org
# 这一行是注释行

条件判断用if语句。

if 条件
   处理代码
elsif 条件 
   处理代码
else
   处理代码
end
#+END_SRC

具体的程序如图2-6所示。

#+BEGIN_SRC org

if box_type(box)=="plain"
  puts("打开箱子")
elsif box_type(box)=="lock"
  puts("用钥匙打开箱子")
elsif box_type(box)=="ribbon"
  puts("解开彩带，打开箱子")
else
  puts("不知道打开箱子的方法")
end

#+END_SRC
图2-6 条件判断程序

当第一个条件成立的时候，就执行第一段处理代码；当第二个条件成立的时候，就执行第二
段处理代码；而当所有条件都不成立的时候，就执行else下面的处理代码。如果处理代码由
多条语句并列构成，不需要用“{}”括起来，而是用elsif或者end等保留词来分隔，这一点
也许会让你觉得耳目一新。

在Ruby的if语句中，elsif部分可以重复出现任意次。当然也可以是0次，这时候elsif是可
以省略的。else同样也是可以省略的。

对于“plain”来说，""中的是字符串。与数值一样，字符串也是能直接写在程序里的数据。
在Ruby中，这些数据都是对象，我们将在以后的章节中详细说明。

像box这样，以小写英文字母开头的是变量。这个例子中已事先设置好了变量的值。像其他
的编程语言一样，变量的赋值语句是

    变量 = 值发送

用来初始化变量。

要判断两个表达式的值是否一样，可以使用“==”运算符。

   表达式 == 表达式

请注意，在赋值语句中是用一个等号，而判断两个表达式更不相等则是用两个等号。这跟
Java 或 C等许多语言中的用法也都是一样的。

后面有小括号的语句是方法调用。如

   puts("打不开箱子")

puts方法可以把字符串显示在画面上。

最后，使用def语句来定义方法。
#+BEGIN_SRC org

  def 方法名 （参数1，……）
      处理代码
  end
#+END_SRC
-----

** 2.2 数据的抽象和继承

多态性、数据抽象和继承被称为面向对象的三原则。这三项原则通常也会有别的称谓。例如，
把多态性称为动态绑定，把数据抽象称为信息隐藏或封装，虽然名称不同，但是内容都是相
同的。许多人认为这些原则是面向对象程序设计的重要原则[fn:2-1-1]。
*** 2.2.1 面向对象的历史

新接触面向对象的人可能觉得它难以理解。事实上，对于从事面向对象编程有15年以上的我
来说，有很多概念还是觉得很难理解。

自20世纪60年代末至今，面向对象的思想已经经过了40多年的发展。猛一看这些一步步积累
起来的成果，你可能会觉得数量庞大。然而，如果沿着面向对象的发展历史一步步开始去学
习的话，那么看起来很难的面向对象概念，实际上比我们想象中的要简单。

首先，我们回顾一下面向对象的发展历史。对不必担心讲解历史过程中提到的一些陌生的词
语，后面会详细说明。

*Simula的“发明”*

如前所述，面向对象编程思想起源于瑞典20世纪60年代后期发展起来的模拟编程语言Simula。
以前，表示模拟对象的数据和实际的模拟方法互相独立的，需要分别管理，编程时需要把两
者正确地结合起来，程序员的负担是很重的。因此，Simula引入了数据和处理数据的方法自
动结合的抽象数据类型。随后，又增加了类和继承的功能。其实在20世纪60年代后期现代面
向对象编程语言的基本特征Simula都已经具备了。


*Smalltalk的发展*

Simula的面向对象编程思想被广泛传播。从20世纪70年代到80年代初，美国施乐公司的帕洛
阿尔托研究中心开发了Smalltalk编程语言。当时的开发宗旨是“让儿童也可以使用”。在
Lisp和LOGO设计思想的基础上，Smalltalk又吸取了Simula的面向对象思想，且独具一格。
不仅如此，它还有一个很好的图形用户界面。这个创新的语言使得世人开始了了解面向对象
编程的概念。


*Lisp的发展*

另外，位于美国东海岸的麻省理工学院及其周边地区，用Lisp语言发展了面向对象的思想。
Lisp和FORTRAN、COBOL语言一样，都是最古老的语言。与同时期登场的其他语言不同，Lisp
语言具有非常浓厚的数学背景，所以它本身具有很强的扩展功能。面向对象的特性也是Lisp
所拥有的。因此，编程语言规格的变更、功能的扩展和实验都很容易进行，由此产生了很多
创新的想法。多重继承、混合式和多重方法等，许多重要的面向对象的概念都是从Lisp的面
向对象功能中诞生的。


*和C语言的相遇*

20世纪80年代，世界上很多地方都在研究面向对象编程思想。AT&T公司的贝尔实验室在C语
言中追加了面向对象的功能，开发出了“C with Class”编程语言。开发者是Biame
Stroustrup，他来自距离Simula的起源瑞典不远的丹麦。在英国剑桥大学的时候，
Stroustrup就使用 Simula 语言。加入贝尔实验室以后，为了能够把C语言的高效率和
Simula的面向对象功能结合起来，他开发了“C with Class”编程语言。

因为当时Simula的处理速度是非常缓慢的，所以在他的研究领域中不能使用。“C with
Class”语言就演变成了后来的C++语言。从这些情况来看，C++是直接受到了Simula语言的
影响，而没有受到Smalltalk多大影响。

*Java的诞生*

强调与C语言兼容的C++语言，能够写低级的方法，这是有利有弊的。为了克服低级语言的缺
点，在20世纪90年代Java编程语言应运而生。Java语言放弃了和C语言的兼容性，并增加了
Lisp语言中一些好的功能。此外，通过Java虚拟机（JVM），Jave程序可以不用重新编译而
在所有的操作系统中运行。

现在，Java作为在20世纪90年代诞生的最成功的语言，被全世界广泛应用。

面向对象编程方法和编程语言一样在不断地演变发展。到了20世纪90年代，面向对象的方法
在软件设计和分析等软件开发的上层领域中流行起来。1994年，当时主要的面向对象分析和
设计方法Booth、OMT(Object Modeling Technique)以及OOSE(Object Oriented Softrware
Engineering)的发明人Grady Booth、Jim Rumbaugh 和Ivar Jacobson合作设计了
UML(Unified Modeling Language)。UML是用来描述通过面向对象方法设计的软件模型的图
示方法，也是利用这种记法进行分析和设计的一种方法论。

UML提供了很多设计高可靠性快软件的面向对象设计方法。但是，UML整体上很复杂，用到的
概念很多，会让初学者觉得很难掌握。

面向对象的基本概念建立以后，催生了各种编程语言。
*** 2.2.2 复杂性是面向对象的敌人

我们再回到面向对象的重要原则，来了解真正的面向对象编程。

软件开发的最大敌人是复杂性。人类的大脑无法做太复杂的处理，记忆力和理解力也是有限
的。

计算机上运行的软件却没有这样的限制，无论多么复杂的计算机软件，无论有多少数据，无
论需要多长时间，计算机都可以处理。随着越来越多的数据要用计算机来处理，对软件的要
求也越来越高，软件也变得越来越复杂。

虽然计算机的性能年年在提高，但它的处理能力终究是有限的，而人类理解力的局限性给软
件生产力带来的限制更大。在计算机性能这么高的今天，人们为了找到迅速开发大规模复杂
软件的方法，哪怕牺牲一些性能也在所不惜。
*** 2.2.3 结构化编程

最初对这种复杂的软件开发提出挑战的是“结构化编程”。结构化编程的基本思想是有序地
控制流程，即把程序的执行顺序限制为顺序、分支和循环这3种，把共通的处理归结为例程
（见图2-7）。
[[/Users/mac/Desktop/ruby p/图2-7.png]]
在结构化编程出现之前，可以用goto语句来控制程序的流程，执行流可以转移到任何地方。
而结构化编程用上文所述的3种语句控制程序的流程。这样可以降低程序流程的复杂性，此
外，还引入了较为抽象的处理块（例程）的概念，也就是把基本上相同的处理抽象成例程，
其中不同的地方由外部传递进来的参数来对应。

结构化编程的“限制”和“抽象化”，是人类处理复杂软件的非常有效的方法。

通过限制大大降低了程序的自由度，减少了各种组合，使得程序不至于太过复杂。但是如果
由于降低了程序的自由度而导致程序的实现能力低下，那是我们所不愿看到的。而结构化编
程的顺序、分支和循环这可以实现一切算法，虽然降低了程序的复杂性和灵活性，但是程序
的实现能力并没有降低。

抽象化的目的是我们只需要知道过程的名字，而并不需要知道过程的内部细节，因此它也被
称为“黑盒化”。我们只需要知道“黑盒子”的输入和输出，而过程的细节是隐藏的。[fn:b22]

例如，如果你知道了例程的输入和输出，那么即使不知道处理的内部细节也可以利用这个例
程。建立一个由黑盒子组合起来的系统，复杂的结构被黑盒子隐藏起来，这样我们就可以更
容易、更好地理解系统的整体结构。

如果把黑盒子内的处理也考虑上，整个系统的复杂性并没有改变。但是如果不考虑黑盒子内
部的处理，系统复杂性就可以降低到人类的可控范围内。此外，黑盒子内部的处理无论怎么
变化，如果输入和输出不发生变化，那么就对外部没有影响，所以这种扩展特性是我们非常
希望获得的。

针对程序控制流的复杂问题，结构化编程采用了限制和抽象化的武器解决问题。结果证明，
结构化程序设计是成功的，并且这种方法已经有了稳固的基础。现在几乎所有的编程语言都
支持结构化编程，结构化编程已经成为了编程的基本常识。
*** 2.2.4 数据抽象化

然而，程序里面不仅包括控制结构，还包括要处理的数据。结构化编程虽然降低了程序流程
的复杂性，但是随着处理数据的增加，程序的复杂性也会上升。面向对象编程就是作为对抗
数据复杂性的手段出现的。

前面已经介绍过了，世界上第一个面向对象和编程语言是Simula。随着仿真处理的数据类型
越来越多，分别管理程序处理内容和处理数据对象所带来的复杂性也就越来越高。为了得到
正确的结果，必须保持处理和数据的一致性，这在结构化编程中是非常困难的。解决这一问
题的方案就是数据抽象技术。

数据抽象是数据和处理方法的结合。对数据内容的处理和操作，必须通过事先定义好的方法
来进行。数据和处理方法结合起来成为了黑盒子。

举一个栈的例子。栈是先入后出的数据存储结构[fn:a222]。比如往快餐托盘中叠加地摞放
食品（见图2-8）。栈只有两种操作方法：入栈（push)，向栈中放入数据；出栈（pop），
把最后放入的数据拿出来。


[[/Users/mac/Desktop/ruby p/图2-8.png]]

我们用Ruby来写这个栈[fn:a223]。图2-9中使用了抽象的数据结构，栈的操作只有push和
pop。别的方法是无法访问栈内数据的。图2-10中则没有使用抽象的数据结构，而是用数组
索引来实现栈的操作。和图2-9相比，哪个更简单是显而易见的。

#+BEGIN_SRC org
 
#用Stack.new 生成新的栈
stack = Stack.new
#对stack进行push操作
stack.push(5)
stack.push(9)

#用Stack的pop方法取出数据
puts stack.pop() #显示9
puts stack.pop() #显示5
#+END_SRC

图2-9 用Ruby写的栈的操作
#+BEGIN_SRC org
#用数组实现的栈的操作
stack = []
# 数组的先头位置
sp= 0

stack[sp]= 5
sp +=1
stack[sp]=9 
sp +=1 

sp -=1
puts stack[sp]
sp -= 1 
puts stack[sp]
#+END_SRC

图2-10 用数组实现图2-9的程序 

图2-9的程序有几点优于图2-10的程序。第一，图2-10的程序暴露了“数组和下标”这一内
部构造，而图2-9则把内部构造隐藏到了stack这一数据结构里。利用图2-9的方法，使用栈
的人并不需要关心栈是如何实现的，即使将来因为什么事情而改变了栈的内部实现方式，也
不需要对使用栈的程序做任何修改。

另外一点是图2-9所示的方法很容易理解。比如数据的push操作，在图2-9中是：
stact.push(5)

在图2-10中是：

stack[sp]=5

sp += 1

图2-9中可以直接表现push这个操作。对数据进行操作的一方，并不需要知道图2-10中的处
理细节，而只对“要做什么”感兴趣。所以隐藏了处理细节的程序会变得更加明确，实现目
的也更清晰。

不仅是操作方法容易理解，抽象数据也是能够对特定的操作产生反应的智能数据。使用抽象
数据可以更好地模拟现实世界中各种活生生的实体。

有了数据抽象，程序处理的数据就不再是单纯的数值或文字这些概念性的东西，而变成了人
脑容易想象的具体事物。而代码的“抽象化”则是把想象的过程“具体化”了。这种智能数
据可以模拟现实世界中的实体，因而被称作“对象”，面向对象编程也由此得名。
*** 2.2.5 雏形

出现在程序中的对象，通常具有相同的动作。以交通仿真程序为例，程序中有表示车和信号
的对象。虽然同样的对象具有相同的性质，但是位置、颜色等状态各有不同。

从抽象的原则来说，多个相同事物出现时，应该组合在一起。这就是DRY原则（即Don't
Repeat Yourself)。

我们已经看到，程序的重复是一切问题的根源。重复的程序在需要修改的时候，所涉及的范
围就会更广，费用也就更高。当多个重复的地方都需要修改时，哪怕是漏掉其中之一，程序
也将无法正常工作。所以重复降低了程序的可靠性。

进一步说，重复的程序是冗余的。人们解读程序、理解程序意图的成本也会增加。让我们再
看看代码重复的图2-10和没有代码重复的图2-9，显然图2-9的程序更容易理解。请记住，计
算机是不管程序是否难以阅读，是否有重复的。然而，开发人员要阅读和理解大量的程序，
所以程序的可读性直接关系到生产力。重复冗长的程序会降低生产力。复制和粘贴程序会导
致重复，应该尽量避免。

让我们再回到对象的话题上。同样的对象大量存在的时候，为了避免重复，可以采用两种方
法来管理对象。

一种是原型。用原始对象的副本来作为新的相同的对象。Self、Io等编程语言采用了原型。
有名的编程语言用原型的比较少，很意外的是，JavaScript也是用的原型。
另外一种是模板。比方说我们要浇注东西的时候，往模板里注入液体材料就能浇注出相同的
东西。这种模板在面向对象编程语言中称为类（class)。同样类型的对象分别属于同样的类，
操作方法和属性可以共享。

跟原型不同，面向对象编程语言的类和对象有明显的区别，就像做点心的模具和点心有区别
一样整数的类和1这个对象、狗类和名字是poochy这条狗也都是有区别的。为了清晰的表明
类和对象的不同，对象又常常被称作实例（instance)。叫法虽有不同，但实例和对象是一
样的。
 
在Ruby面向对象编程语言[fn:page21]中，类用关键字class来声明。图2-9中的栈，就是
Stack类。Stack类的定义如图2-11所示。

class后面是类名。在图2-11中，class后面就是Stack。Ruby规定类名称的第一个字母必须
大写。类定义的最后用end。在Stack这个类中，定义了initialize、push、pop这三个方法。

图2-9的程序第二行调用了intialize这个初始化方法。

stack = Stack.new

#+BEGIN_SRC org
class Stack
  def initialize
    @stack=[]
    @sp=0
  end

  def push(value)
    @stack[@sp]=value
    @sp+=1 
  end

  def pop
    return nil if @sp==0
    @sp-=1 
    return @stack[@sp]
  end
end
#+END_SRC
图2-11 Stack类的实现

每次生成Stack对象的时候，都要调用initialize这个初始化方法。

在图2-11的初始化方法中，@stack（实际保存栈数据的数组）和@sp（数组下标）这两个变
量被初始化。在Ruby中以“@”开头的变量用来保存每个对象中分别独立存在的值，也称为
实例变量。如果你创建了多个栈对象，那么每个对象里面都分别有自己独立的@stack和@sp
这两个变量。

push和pop是操作栈的方法。在图2-10中不过是罗列了对栈的操作步骤罢了。

图2-11的initialize是对类定义的操作对象的内部数据进行初始化的“方法”。

为了简化说明，图2-11的例子中没有检查数据的范围。事实上，程序中需要检查下标是否为
负值等。
*** 2.2.6 找出相似的部分来继承

随着软件规模的扩大，用到的类的个数也随之增加，其中也会有很多性质相似的类。这就违
背了我们之前强调多次的DRY原则。程序会变得重复而且不容易理解。修改程序的代价也会
变高，生产力则会降低。所以，如果有把这些相似的部分汇总到一起的方法就好了。

继承就是这种方法。具体来说，继子就是在保持即有类的性质的基础上生成新类的方法。原
来的类称为父类，新生成的类称为子类。子类继承父类所有的方法，如果需要也可以增加新
的方法。子类也可以根据需要重写从父类继承的方法。

图2-12演示了FixedStack这个类，它继承了图2-11中的Stack类。类名后面的“<Stack”指
的是父类。它说明了FixedStack是Stack的子类，继承了Stack类的方法和属性。

FixedStack类重写了initialize和push这两个方法。这两个方法都调用了super方法，这表
明在子类的方法中也调用了父类的具有相同名字的方法。比如在FixedStack类的initialize
方法中也调用父类Stack的initialize方法。利用这种方式，我们可以只改变子类方法的动
作，而不会对父类方法产生任何影响。

initialize 方法在对象初始化时被调用。如果像下面的程序一样，在调用initizlize方法
时传入参数10，那么栈对象的实例变量@limit就会被设置为10，它是栈中元素个数的上限。

stack=FixedStack.new(10)

在图2-12中，程序末尾追加了并不把栈顶元素弹出栈而只是引用栈顶元素的方法top。top在
父类中交没有定义，这是一个在子类中追加方法的例子。

#+BEGIN_SRC org
class FixedStack<Stack
  def initialize(limit)
    super()
    @limit=limit
  end

  def push(val)
    if @sp>=@limit
     puts "over limit"
     return
    end
    super(val)
   end

  def top 
    return @stack[-1]
  end
end
#+END_SRC
图2-12 用类来继承图2-11中类的例子。

  
像图2-12这样，利用现有的类派生新类的方法称为“差分编程法”（difference
programming)。通过抽象把共通的部分提取出来生成父类，与利用已有的类来生成新类，是
同一方法的两种不同的表现形式。前者称为自底向上法，后者称为自顶向下法。

Ruby跟多数编程语言一样，一个子类只能有一个父类，这称为“单一继承”。从自顶向下的
方法来看，通过扩展一个类来生成新的类也是很自然的。

但是，从用自底向上的方法提取共通部分的角度来看，一个子类只能有一个父类的限制是太
严格了。其实，在C++、Lisp等编程语言中，一个子类可以有多个父类，这称为“多重继承”。
** 2.3 多重继承的缺点

上一节讲解了面向对象编程的三大原则（多态性、数据抽象和继承）中的继承。如前所述，
人们一次能够把握并记忆的概念是有限的，为解决这一问题，就需要用到抽出类中相似部分
的方法（继承）。继承是随着程序的结构化和抽象化自然进化而来的一种方式。

但最后一句话严格来说并不完全正确。结构化和抽象化，意味着把共ceep部分提取出来生成
父类的自底向上的方法。如果继承是这样诞生的话，那么最初，有多个父类的多重继
承[fn:page23]就会成为主流。

但实际上，最初引入继承的Simula编程语言，只提供单一继承。同样，在随后的很多面向对
象编程语言中也都是这样的。因此我认为，继承的原本目的实际上是逐步细化。
*** 2.3.1 为什么需要多重继承

单一继承只能有一个父类。有时候，大家会觉得这样的制约过于严格了。在现实中，一个公
司职员同时也可能是一位父亲，一个程序员同时也可能是一位作家。

正如上一节中说明的，如果把继承作为抽离出程序的共通部分的一个抽象化手段来考虑，那
么从一个类中抽象化（抽出）的部分只能有一，这个假定会给编程带来很大的限制。因此，
多重继承的思想就这样产生了。单一继承和多重继承的区别仅仅是父类的数量不同。多重继
承完全是单一继承的超集，可以简单地看做是单一继承的一个自然延伸（图2-13）。

可以使用多重继承的编程语言，不受单一继承的不自然的限制。例如，只提供单一继承的
Smalltalk语言，它的类库因为单一继承而显得很不自然。
[[/Users/mac/Desktop/ruby p/图2-13.png]]

Smalltalk语言中定义输入输出的Stream类有3个子类。其中，ReadStream是输入类，
WriteStream是输出类，ReadWriteStream是输入输出类。ReadWriteStream具有ReadStream
和WriteStream两个类的功能，但是由于Smalltalk是单一继承的，所以ReadWriteStream不
能同时从这两个类继承。

结果是ReadWriteStream继承了WriteStream这个类，然后再把ReadStream的程序复制过来，
从而实现ReadStream的功能（参见图2-14）。从程序维护的观点来看，程序复制是必须禁止
的。由于单一继承的限制而导致的程序复制是我们不愿意看到的。

从另外的角度来看，如果有多重继承的话，那么很自然地从ReadStream 和 WriteStream继
承就可以生成ReadWriteStream（参见图2-15）。
*** 2.3.2 多重继承和单一继承不可分离

经过对多重继承和单一继承这样一比较，单一继承的特点就很明显了。

*- 继承关系单纯*

单一继承的继承关系是单纯的树结构，这样有利有弊。类之间的关系单纯就不会发生混乱，
实现起来也比较简单。但是，如刚才的Smalltalk的Stream一样，不能通过继承关系来共享
程序代码，导致了最后要复制程序。

对需要指定算式和变量类型的Jave这样的静态编程语言来说，单一继承还有一个缺点，我们
将在后面说明。
[[/Users/mac/Desktop/ruby p/图2-14.png]]
[[/Users/mac/Desktop/ruby p/图2-15.png]]

多重继承的特点正好相反。多重继承有以下两个优点：

- 很自然地做到了单一继承的扩展；
- 可以继承多个类的功能。

单一继承可以实现的功能，多重继承都可以实现。但是，类之间的关系会变得复杂。这是多
重继承的一个缺点。
*** 2.3.3 goto语句和多重继承比较相似

前面我们讲到了结构化编程，说明了与其用goto语句在程序中跳来跳去，还不如用分支或者
循环来控制程序的流程。分支和循环可以用goto语句来实现，单纯的分支和循环组合起来不
能直接实现的控制也可以用goto语句来实现。goto语句具有更强的控制力。

goto语句的控制能力虽然很强，但是我们也不推荐使用。因为用goto语句的程序不是一目了
然的，结构不容易理解。这样的流程复杂的程序被称为“意大利面条程序”。

多重继承也存在同样的问题。多重继承是单一继承的扩展，单一继承可以实现的功能它都可
以实现。用单一继承不实现的功能，多重继承也可以实现。

但是，如果允许从多个类继承，类的关系就会变得复杂。哪个类继承了哪个类的功能就不容
易理解，出现问题时，是哪个类导致的问题也不容易判明。

这样混合起来发展的继承称为“意大利面条继承”。当期也不能说所有的多重继承都是意大
利面条继承，但是使用时格外小心是必要的。多重继承会导致下列3个问题。

*. 结构复杂化*

如果是单一继承 ，一个类的父类是什么，父类的父类又是什么，都很明确，因为只有单一
的继承关系。然而如果是多重继承的话，一个类有多个父类，这些父类又有自己的父类，那
么类之间的关系就很复杂了。

*. 优先顺序模糊*

具有复杂的父类的类，它们的优先关系一下子很难辨认清楚。比如图2-16中的层次关系，D
继承父类方法的顺序是D、B、A、C、Object还是D、B、C、A、Object,或者是其他的顺序，
很不明确。确定不了究竟是哪一个。相比之下，单一继承中类的优先顺序是明确了然的。

*. 功能冲突*

因为多重继承有多个父类，所以当不同父类中有相同的方法时就会产生冲突。比如在图2-16
中，当类B和类C有相同的方法时，D继承的是哪个方法就不明确了。存在两种可能性。
*** 2.3.4 解决多重继承的问题

上面说明了多重继承的问题。但是像Smalltalk的Stream的例子一样，如果没有多重继承的
话，有些问题还真是难以解决。

再进一步看，继承做为抽象化的手段，是需要实现多重继承功能的。在抽取类的共通功能的
时候，如果一个类只允许抽出一个功能，那么限制就太多了。
[[/Users/mac/Desktop/ruby p/图2-16.png]]

既想利用多重继承的优点，又要回避它可能会带来的问题，那我们就需要寻找解决问题的方
法。结构化编程解决goto问题的原则是，用3种有限制功能的控制语句来代替自由度太高的
goto语句。这3种控制语句虽然有限制，但是用它们的组合可以实现任意算法。像这样引入
有限制的多重继承应该是一个好的方法。

没错，受限制的多重继承，这个解决或者改善多重继承问题的方法出现了，它在Jave编程语
言中被称为接口（interface），在Lisp或者Ruby中是Mix-in。下面我们看看这些功能是如
何克服上述缺点的。
*** 静态语言和动态语言的区别

我们从Java的接口说起

在说明接口之前，首先讲一下像Java这样的面向对象编程语言和多重继承。

从在的方面来看，编程语言可以分为静态语言和动态语言两种。像Java这样规定变量和算式
类型的语言称为静态语言。

在静态语言中，不能给变量赋不同类型的值，因为那样会导致编译错误。由于在编译时已经
排除了类型不匹配的错误，所以在执行时就不会再发生这样错误了。不通过执行就可以发现
类型不匹配这样的错误是静态语言的一个优点。

String str;

str="abc";    //没有问题

str=2;        //编译错误

面向对象编程语言大都用类来指定变量类型。上面例子用的就是String这个类。但是在使用
面向对象编程语言时，像上面的例子那样，只能将特定类的对象（该类的实例）赋给变量的
限制的确又太严格了，因为这样的话就没有多态性了。如果只能给一个变量赋值同类对象，
就不可能根据对象的类自动选择合适的处理方式（多态性）。
*** 2.3.6 静态语言的特点

为解决这一问题，静态类型面向对象编程语言被设计成这样，当给一个类变量赋值时，既可
以用这个类的对象来赋值，也可以用这个类的子类对象来赋值。这样就可以实现多态性。

请看图2-17中和程序。这是一个用Java风格的静态语言来定义多边形类的例子。最后出现的
poly是polygon类的一个变量，所以通过poly应该可以调用polygon类的方法（比如“面积”
方法）。但实际上，poly这个变量的值是polygon子类Rectangle的对象，所以通过poly调用
的就是Rectangle的方法。当然，如果调用的方法只在polygon中定义而没有在Rectangle中
定义，那就会调用Polygon中定义的方法。

但是反过来说，在程序中poly就是Polygon类的变量，即使它的值明明是Rectangle类对象，
用poly这个变量也不能调用Rectangle类中固有的方法（比如“边长”）。
#+BEGIN_SRC org
//多边形类
class Polygon
{
   float 面积（）{……}
   int 顶点数 （）{……}
   ……
};

//矩形类（继承多边形类）
class rentangle extends Polygon
{
    float 面积（）{……}//再定义面积计算方法
    int 边长（）{……} //矩形类特有的方法
    ……
}；

Polygon poly;
poly=new Rectangle();
#+END_SRC

图2-17 父子关系的类的示例，变量不能调用子类特有的“边长”方法

换个说法就是，变量只是实际赋值对象的一个小观测窗口。即使作为变量值的对象有很多方
法，但在使用这个变量来调用方法时，只能调用该变量类型“知道”的方法。

如果变量poly调用“边长”方法的话，静态语言会毫不留情地报告编译错误。

而像Ruby这样没有类型定义的动态编程语言，是在程序执行时才来试着调用对象的方法，在
实际对象没有可被物方法时程序才会报错。
*** 2.3.7 动态语言的特点

动态语言允许调用没有继承关系的方法。比如说Ruby中定义了顺序取出某个元素的方法each，
数据和哈希表中都实现了这个方法。
#+BEGIN_SRC org
obj.each {|x|
    print x
}
#+END_SRC

在静态语言中只能调用有继承关系的方法，数据、哈希表和字符串都能调用的方法只能是在
它们共同的父类（恐怕就是Object）中定义。

这是单一继承的一个缺点，以后会详细说明。

在静态语言中，如果要调用类层次中平行类的方法，那么必须要有一个可以表现这些对象的
类型。如果没有这个类型，可调用的方法是非常有限的。由此我们看到静态语言中某种形式
的多重继承是不可少的。
*** 2.3.8 静态语言和动态语言的比较

静态语言和动态语言各有利弊。静态语言即使不通过执行也可以检查出类型是否匹配。在一
定程度上，程序的一些逻辑错误可以被自动检测出来。

但是，逐个来定义算式和变量的类型又会使程序变得冗长。只有包含继承关系的类才会具有
多态性。相对于动态语言来说，静态语言就显得限制过多，灵活性差。

动态语言则正好相反。程序中有没有错误只有执行了才会知道。从可靠性来看也许会让你感
觉有些不安。程序中没有类型定义，这样程序会变得很简洁，但别人看起来或许会有点难懂。

但是，只有方法名一样，这些对象都可以以相同的方式去处理。也就是说不需要深层次探索
类也可以开发程序。这样生产效率就会大大提高[fn:page28-1]。
*** 2.3.9 继承的两种含义

像java这样的静态面向对象编程语言的变量，具有限制调用方法的功能。但实际上限制的是
类有什么样的方法，而不是这个类是怎么实现的。

到现在为止我们一起都在讨论继承，其实包含两种含义。一种是“类都有哪些方法”，也就
是说这个类都把持些什么操作，即规格的继承。

另外一种是，“类中都用了什么数据结构和什么算法”，也就是实现的继承。

静态语言中，这两者的区别很重要[fn:page28-2]。Java就对两者有很明确的区分，实现的继
承用extends来继承父类，规格和继承用implements来指定接口。

类是用来指定对象实现的，而接口只是指定对象的外观（都有哪些方法）。

Java中，只允许用extends继承一个父类（实现的继承），所以类的继承是单一的。类的关
系树和类库也就相对简单。

然而，implements可以指定多个接口（规格的继承）。接口规定了要怎样处理该对象。

举个具体例子说明一下。我们来看看图2-18中java.util.Collection这个接口的类层次。
java.util.Collection是定义集合的接口，有2个接口来继承它，分别是按顺序存放元素的
java.util.List和没有重复元素的java.util.Set。也就是说，实现了java.,util.List或
java.util.Set的对象也可以被当做java.util.Collection来处理。


[[/Users/mac/Desktop/ruby p/图2-18.png]]
接口对实现没有任何限制。也就是说，接口可以由跟实现的继承没有任何关系的类来实现。
也就是说，实现这一接口的类可以继承任何其他类。例如在java.util包中，作为
java.util.List的实现，既提供用数组实现的java.util.ArrayList，也提供用双向链表实
现的java.util.LinkedList。这些类都直接继承Object类。
*** 2.3.10 接口的缺点

关于规格继承和实现继承的区别，很久以前就有论文进行了相关的探讨。但在众多得到广泛
运用的编程语言中，Java是第一个实现这种功能的。这可以说是Java对多重继承问题的解答。
既实现了静态语言的多重继承性，又避免了多重继承的数据构造的冲突和类层次的复杂性。

但是，我们并不能说接口是解决问题的完美方案。接口也有不能共享实现的缺点。

为了解决多重继承的问题，人们允许了规格和多重继承，但是还是不允许实现多重继承。针
对这一点，我们不太好再说什么，但作为用户，就是觉得不方便。Java推荐的解决共享实现
问题的方案是，在单一继承的前提下，使用组合模式（Composite）来调用别的类实现的共
通功能。

本来只是为了跨越继承层次来共享代码，现在却需要另外生成一个独立对象，而且每次方法
调用都要委派给那个对象，这实在是不太合理，而且执行的效率也不高。
*** 2.3.11 继承实现的方法

和静态语言Java不同，动态语言本来就设有继承规格这种概念。动态语言需要解决的就是实
现的多重继承。

动态语言是怎么解决这一问题的呢？Lisp、Perl和Python都提供了多重继承功能，这样就不
存在单一继承的问题了。在这些语言中，使用多重继承时请千万小心。
*** 2.3.12 从多重继承变形而来的Mix-in

Ruby采用了和Java及其他动态语言都不同的方法。Ruby用Mix-in 模块来解决多重继承的问
题。

Mix-in是降低多重继承复杂性的一个技术，最初是在List中开始使用的。实现Mix-in 并不
需要编程语言提供特别的功能。Mix-in技术按照以下规则来限制多重继承。

- 通常的继承用单一继承
- 第二个以及两个以上的父类必须是Mix-in 的抽象类

Mix-in类是具有以下特征的抽象类。

- 不能单独生成实例
- 不能继承普通类

按照这个原则，类的层次具有和单一继承一样的村结构，同时又可以实现功能共享。实现功
能共享的方法是把共享的功能放在Mix-in 类里面，然后把Mix-in 类插入到树结构里面。相
对于Java用接口方法解决规格继承的问题，那么Mix-in 可以说是解决了实现继承的问题。

我们看一个Mix-in 的具体例子。针对图2-14、图2-15中的Smalltalk的Stream问题，图
2-19显示的是用Mix-in构建的一个相同结构。

[[/Users/mac/Desktop/ruby p/图2-19.png]]


在使用Min-in 的类结构中，Stream只有3个子类。在此基础上，实际的输入/输出处理用
Readable(输入）和Writable(输出）这两个Mix-in 类实现。3个子类通过继承Mix-in类而分
别实现了输入、输入以及输入和输出的功能。

从Stream的类层次来看，父类是Stream，负责输入输出的是ReadStream、WriteStream 和
ReadWriteStream这3个子类，它们形成了非常清晰的树结构。层次很简单，没有变成网状结
构。而且，由于Mix-in类实现了共通功能，从而避免了复制代码。

和一般的多重继承相比，Mix-in是使类结构变得简单的优秀技术。使用Min-in规则来限制多
重继承，实际上也可以说是“驯服”了多重继承。

这和结构化编程用分支和循环来限制随意的goto语句是一样的。Mix-in可以应用于所有的多
重继承编程语言中，因此，掌握这个技术是非常有必要的。
*** 2.3.13 积极支持Mix-in的Ruby

和其他直接引入多重继承的编程语言相比，Ruby具有直接支持Mix-in 的特点。在Ruby中，
Mix-in的单位是模块（module)。模块具有Mix-in的特性，即：

- 不能生成实例；
- 不能从普通类继承。

下面我们看看在Ruby中是怎样使用Mix-in的。图2-20演示了Ruby是怎样实现图2-19的Stream
类的定义的。

模块用关键字module来定义，这和定义类用关键字class相似，但是不能指定它的父类。其
中方法等的定义与类也是一样的。

在类中通过include可以继承模块中的方法。因为是继承而不是复制，所以当类中有同样的
方法时，类中的方法就会优先执行。

关于继承的各方面内容，我们都总结到了表2-2中。

表2-2 与继承有关的内容

| 用语               | 内容                                                                                                             |
|--------------------+------------------------------------------------------------------------------------------------------------------|
| 单一继承           | 只能有一个父类，单纯但存在几个问题                                                                               |
|--------------------+------------------------------------------------------------------------------------------------------------------|
| 多重继承           | 可以有多个父类，解决了单一继承的问题（面向对象的编程语言需要某种形式的多重继承），但引入了单一继承所没有的新问题 |
|                    |                                                                                                                  |
|--------------------+------------------------------------------------------------------------------------------------------------------|
| 静态语言           | 区分规格的继承和实现的继承                                                                                       |
|--------------------+------------------------------------------------------------------------------------------------------------------|
| 动态语言           | 只有实现的继承                                                                                                   |
|--------------------+------------------------------------------------------------------------------------------------------------------|
| 规格多重继承的问题 | Java的接口可以解决                                                                                               |
|--------------------+------------------------------------------------------------------------------------------------------------------|
| 实现多重继承的问题 | Mix-in可以解决                                                                                                   |
|--------------------+------------------------------------------------------------------------------------------------------------------|
| Mix-in             | 所有支持多重继承的语言都可以考虑使用                                                                             |
|--------------------+------------------------------------------------------------------------------------------------------------------|
| Ruby的Mix-in       | 强制利用模块，积极解决多重继承的问题                                                                             |
|--------------------+------------------------------------------------------------------------------------------------------------------|

#+BEGIN_SRC org
# Stream 类，Object的子类
class Stream <Object

   # 这里的定义省略
   ……

end

#输入用Mix-in
module Readable

  # 定义输入用的方法
  def read
  ……
  end

#输出用Mix-in 
module Writable

  #定义输出用的方法
  def write(str)
    ……
  end

end

# 输入用Stream,Stream 的子类
class ReadStream < Stream

   #继承输入用的Mix-in
   #Ruby称谓include
   include Writable

end

#输入输出用Stream,Stream 的子类
class ReadWriteStream <Stream

   #继承输入用Mix-in
   include Writable

end

#+END_SRC

图2-20 用Ruby实现图2-19 的Stream类的定义
**  2.4 两个误解

本节将说明一下关于对面向对象的误解。

作为一个很早就接触面向对象编程语言的爱好者，我写过关于面向对象的文章，开发了面向
对象编程语言Ruby。我觉得自己为让更多的人都能够熟悉面向对象编程语言作出了贡献。我
骄傲的认为，Ruby比Smalltalk更容易上手，比Java和C++更容易实现面向对象编程，从而使
人们更容易理解面向对象的概念。

但是，在这个过程中，由于我的不成熟，可能会加深一些人对面向对象的误解。

在这些误解中，有两个是我很在意的。

一个误解是，对象是对现实世界中具体物体的反映，继承是对物体分类的反映。这个观点是
错误的。我之前写过的《面向对象编程语言Ruby》[fn:page31]中也用哺乳动物，比如狗和
鲸等举过例子，可能也加深了这种误解。

另一个是，多重继承是不好的。这个观点也是错误的。这一误解好像还大都与“但Mix-in不
错”[fn:page322]的误解掺和在一起。

在解释之前我先表明一下正确的观点。关于多重继承，正确的理解应该昌，如果用得不好就
会出问题。对Mix-in的理解应该是，Mix-in只不过是实现多重继承的一个技巧而已。

Ruby 只支持Mix-in形式的多重继承。这是因为在当时Mix-in这种技术还不广为人知，我只
是想把多重继承作为一种启蒙，并没有贬低多重继承的意思。这可能造成了有人认为多重继
承不好的误解。曾有一个著名的青年学者因为Ruby的原因而误认为多重继承和Mix-in是不同
的概念。这也是我要反省的一点吧。

当然，我也不觉得这些误解全都是我造成的。但是，为了减少这些误解，下面再讲解一下面
向对象编程语言和多重继承。
*** 2.4.1 面向对象的编程方法
从历史上看，从20世纪60年代末期到70年代，分别有几个不同领域都发展了面向对象的思想。
比如数据抽象的研究、人工智能领域中的知识表现（框架模型）、仿真对象的管理方法
（Simula）、并行计算模型（Actor）以及在结构化编程思想影响下而产生的面向对象方法。

框架模型是现实世界的模型化。从这个角度来看，“对象是对现实世界中具体事物的反映”
这个观点并没有错。

但是不管过去怎样，现在对面向对象最好的理解是，面向对象编程是结构化编程的延伸。

计算机最初出现时，对软件的要求是非常简单的，只是把人完成工作的步骤用汇编或者机器
语言表现出来，编程并不是很难的工作。但是随着软件的复杂化，开发就变得越来越复杂。
因为这个原因，Edsger Dijkstr[fn:page331]提倡把程序控制限制为以下3种的组合，使程
序变得简单且容易理解。

    （1） 顺序————程序按照顺序执行。
    （2） 循环————一定的条件成立时程序反复执行。
    （3） 分支————条件满足时执行A处理，不满足时执行B处理。
结构化编程基本上实现了控制流程的结构化。但是程序流程虽然结构化了，要处理的数据却
    并没有被结构化[fn:page332]。面对对象的设计方法是在结构化编程对控制流程实现了
    结构化后，又加上了对数据的结构化。

众多面向对象的编程思想虽不尽一致，但是无论哪种面向对象编程语言都具有以下的共通功
能。

    （1) 不需要知道内部的详细处理就可以进行操作（封装、数据抽象）。
    （2） 根据不同的数据类型自动选择适当的方法（多态性）。

可以这样认为，以下两点在面向对象编程语言中是必不可少的。因为不必知道内部结构，所
以可以把数据当做黑盒来操作。即使将来数据结构发生变化，对外部也没有影响。黑盒化是
模块化折基本原则，面向对象编程语言将每一类数据都当做黑盒处理。

多态性是根据不同的荋 自动选择适当的处理。这就不需要由人来根据不同的数据类型对处
理进行分支了。如果没有多态性，那么程序中就会到处是分支处理。这也就意味着，变更和
追加数据类型会变得非常困难。

在面向对象分析和面向对象设计领域，有些观点还不尽一致，但如果只谈面向对象编程，就
可以认为封装和多态性是提高生产率的技术。

如果把面向对象编程看做是对结构化编程的扩展，那么对象是否是现实世界中具体物体的反
映就不重要了。实际上，面向对象编程语言中的对象，像字符串、数组和范围等，很多都没
有现实世界中的具体物体与之对应。即使现实世界中有具体物体与之对应，对象也只是描述
现实物体的某一侧面的抽象概念而已。比如猫有颜色、血统等很多属性，而程序中的对象并
不需要把这些属性都考虑进去。程序只是处理抽象数据的。
*** 2.4.2 对象的模板=类

很多面向对象编程语言都具有类和继承这两个基本特性。利用这两个特性，我们可以高效地
把抽象的数据通过类封装起来。

类是对象的模板，相当于对象的雏形。在具有类功能的面向对象编程语言[fn:page3301]中，
对象都是由作为雏形的类来生成的，对象的性质也是由类来决定的。通过类可以把同一类的
对象管理起来。

图2-21显示的是Ruby中对类的定义。我一般情况下是用阿猫阿狗来举例的，但为了避免误解，
这次用数据结构的栈来举例。

栈是LIFO(后入先出）的数据结构。可以按照从后向前的顺序把里面的数据取出来。图2-21
的程序里定义了两个栈，s1和s2，分别对它们放入和取出数据。两个栈都是由相同的类生成
的对象，操作方法都一样。但是，它们的数据都是独立的，交互对两个栈进行操作也不会破
坏彼此的数据。

我们可以把面向对象编程语言的类看做是结构化编程语言的结构体或记录的扩展。不同的是，
类里面不仅有被称为成员或字段的数据，而且还有对这些“数据块”进行操作的方法。

对于只是把数据组织在一起的结构体，我们能做的只是取出或者更新成员变量的值。而类中
定义有成员函数（也称为方法），可以调用这些方法来处理类的对象。

例程能够把一系列的处理步骤组织在一起，把处理的内容黑盒化，是个很有用的工具，而类
则是把数据黒盒化的工具。由于对类内部数据的操作都是通过类的方法来实现的，所以内容
数据结构即使在以后发生变化，对外部也没有影响。这和例程把处理黒盒化之后，内部算法
变化对外部没有影响是同样的道理。

像这样不用考虑内部处理的黑盒化也被称为抽象化。是降低程序复杂度的有效方法。
*** 2.4.3 利用模块的手段=继承

类以数据为核心，把与之相关的处理也都集中到一起。这样，模块之间一些具有共通性质的
内容就会重复出现，从而违背了禁止重复的DRY原则[fn:page341]。

避免重复的方法是继承。那些具有相同性质的类可以从拥有共通性质的类中“继承”这些共
通的部分。不单是可以继承，还可以替换，追加其中不同的部分，从而生成新的类。

人这个角度来看，类是模块，继承就是利用模块的方法。继承的思想好像有其现实的知识基
础，但是把它看做纯粹的模块利用方法则更恰当。

因为继承只不过是抽象的功能利用方法，所以不必把对继承的理解束缚在“继承是对现实事
物的分类的反映”。实际上这样的想法反而是非常妨碍了我们对继承的理解。

关于继承，规格继承和实现继承的区别也是非常重要的话题。规格就是从部看到的类的功能，
这样的继承是规格继承。实现继承是批继承功能的实现方法。

传统面向对象编程语言是一下子把规格和实现都继承下来，在最近的编程语言中，有的是把
这两种继承分开了。比如Java里的接口就是规格继承，而在Sather编程语言中，规格继承和
实现继承被完全分离开了。
*** 2.4.4 多重继承不好吗

在早期的面向对象编程语言中，基功能被继承的类（基类或者父类）被限定为一个，这称为
单一继承（或者单纯继承）。

把单一继承自然地扩展，一个类可以继承多个类的功能，就成为了多重继承。在自然界中也
是一样，家长不只有一个。一个程序员同时也可能是一位父亲，同时具有多个角色。所以从
单一继承到多重继承是很自然的。

但是，像Java和Smalltalk这样，不支持多重继承的编程语言还有很多，在程序员中多重继
承好像也不是很普及，其中认为“多重继承是不好的东西”的人并不少。

单一继承的类之间的关系是很单纯的树结构。但是对多重继承而言，类之间的关系却是复杂
的网状结构。

正因为如此，多重继承在一部分开发者当中的评价并不好，但是考虑到程序的生产力，多重
继承不是必要的。

对于像Java或者C++这样需要指定变量类型的静态语言来说，父类类型的变量可以用子类的
对象来赋值。如果用子类以外的对象来赋值的话，就会发生编译错误。所以可以说这既实现
了多态性，又实现了对变量类型的检查，是 一个很好的想法[fn:page342]。

结果是，静态语言中可以实现多态性的只是限于拥有共父类的对象。

但是，把对象统一处理的观点可能不止一个。比如对于字符串类，如果着眼于能够比较大小
这一性质的话，我们有时想把它与数值等统一处理。这时我们可能会创建一个能够比较大小
的父类，让数值和字符串来继承这个父类。

而在同一程序中别地地方，考虑到字符串类是字符的序列，为能实现把其中的元素按照顺序
取出的操作，又想把它与列表等统一处理。这就需要给字符串和列表定义一个共通的父类。
但是单一继承只能有一个父类，不可能同时实现比较大小和按顺序访问这两个要求。

所以，为了解决这个问题，多重继承在静态编程语言中是必要的。实际上，静态面向对象编
程语言的代表C++和Eiffel[fn:page351]都支持多重继承。Java也可以通过接口来支持规格
和多重继承。
*** 2.4.5 动态编程语言也需要多重继承

动态编程语言没有类型检查，从这方面来说没有理由用多重继承。那么动态编程语言真的不
需要多重继承吗？

肯定不是这样的。

无论从类型上考虑结果如何，从模块的角度来看，单一继承也有很多不便性。比如“一个文
件只能利用一个库”这样的限制就让我们感到很不自由。

当然，实现的共享可以通过多个对象的组合（composition)和委托(delegate)[fn:page352]
来做到，Java中就推荐这种方法。

但是如果把类当做模块来看的话，多重继承相当于语言功能支持模块组合。有了多重继承，
同样的处理可以简单地记述，可以促进实现的共享。从DRY原则的角度来看，今后的面向对
象语言也应该支持多重继承。
*** 2.4.6 驯服多重继承的方法

多重继承因为有多个父类，所以可能引发下面两个问题。

（1） 类关系复杂化。

（2） 继承功能名字重复。

最初的问题起因是类的关系从简单的树结构变成了复杂的网状结构。单一继承时，子类和父
类、父类和它的父类……之间的关系是一条直线。

多重继承时，类之间的关系变成由一个类作为顶点的有向图。如图2-22所示，优先级不能被
简单地确定。图2-22左边显示的是单一继承的例子。类C和父类之间的优先级是C-B-A,简单
而明确。右边显示的是多重继承的例子。类5的父类有类1、类2、类3和类4，但是父类之间
的优先级并不明确。

[[/Users/mac/Desktop/ruby p/图2-22.png]]

解决优先级问题需要巧妙的设计，设计好的话，就不会有（或难以发生）问题。多重继承确
实容易让类之间的关系变得复杂。不管怎么说，和单一继承相比，这个一个很显眼的缺点。
但是如果能够进行巧妙和适当的设计，大部分场合这个问题是可以避免的。

多重继承设计的一个有效的技巧是Mix-in。Ruby也利用了这个技巧。

用Mix-in做多重继承设计时，从第2个父类开始的类要满足以下条件。

（1）不能单独生成实例的抽象类。

（2）不能继承Mix-in以外的类。

满足这两个条件的类称为MIx-in类。正是因为这些限制，Mix-in类可以说是功能模块。通过
Mix-in类的功能和一般类的组合，继承关系既单纯，又可以享受多重继承的优点。

有这么多的限制，对于Mix-in的实用性，恐怕有人会抱有怀疑的态度。

其实一般的继承是可以变换成基于Mix-in的关系的。请看图2-23和图2-24。图2-23是Window
类的多重继承关系。在一般的Window类上，加上标题栏就是Titledwindow类，加上边框就是
FramedWindow类，既有标题又有边框的是TitledFramedWindow类。TitledFramed-Window类
分别继承了TitledWindow类和FramedWindow类。

而在图2-24中，用Mix-in实现了相同的功能。标题功能和边框功能分别被做成两个Mix-in类，
这样TitledWindow类、FramedWindow类和TitledFramedWindow类就成为了3个独立的类。

这样，通过对功能的分离，多重继承就可以由单一继承加上Mix-in类来实现。利用Mix-in就
可以同时享有单一继承的单纯性和多重继承的共有性。

[[/Users/mac/Desktop/ruby p/图2-23-24.png]]

另外一个比较麻烦的问题是名字重复。多重继承编程语言都有自已的对应方法，大致上分为
以下3种。

（1）给父类定义优先级

重复的时候使用优先级高的父类属性。Common Lisp Object System(CLOS)提供的这个功能
在继承数据类型时很有效。

（2）把重复的名字替换掉

Eiffel使用的就是这种方法。在模块继承时用这种方法很有效，其缺点是写程序时很复杂。

（3）指定使用类的名字

C++用的是这种方法。这也是在继承模块时有效的方法。缺点是本来不需要指定类名的情况
现在却要指定。

从对应方法可以明白地看到各种语言的特点。Lisp重视数据类型的继承，Eiffel和C++重视
模块的继承。
*** Ruby中多重继承的实现方法

当初设计Ruby的时候，Mix-in并不广为人知。我认为Mix-in是解决多重继承问题的非常好的
方法。所以，出于启蒙的目的，我特意在Ruby中强制采用了Mix-in，而没有使用普通的多重
继承。

不知道是否因为这个原因，Mix-in的知名度提高了。但是也像前面说过的一样，甚至一些计
算机科学的研究者也产生了对多重继承的误解。

我们比较一下在Ruby中使用和不使用Mix-in的区别。图2-25是使用Mix-in的Ruby程序。用
module定义的是Mix-in类。

图2-25的LockingMixin可以对任意的类提供lock功能。在这里，给Printer类增加了lock功
能。在spool方法中调用了lock方法。

图2-26是没有Mix-in的Ruby程序。这里增加了实现Lock功能的对象初始化，添加了Lock方法，
还要定义很多方法的委托调用。比较起来，Mix-in程序就很简洁。

#+BEGIN_SRC org

module LockingMixin

  def lock
    ……
  end
  def unlock
   ……
  end
end

class Printer<Device

  include LockingMixin
  def spool(text)
    lock
    ……
    unlock
  end
end
#+END_SRC

图2-25 利用Mix-in 的Ruby程序

#+BEGIN_SRC org

class LockingMixin

  def lock
    ……
  end
  def unlock 
    ……
  end
end

class Printer<Device

  def initialize
    @lock=Lock.new
  end
  def lock
    @lock.lock
  end
  def unlock
    @lock.unlock
  end
  def spool(text)
    @lock.lock
    ……
    @lock.unlock
  end
end
#+END_SRC

图2-26 不用Mix-in来实现图2-25的功能
*** 2.4.8 Java实现多重继承的方法

Java采用了单一继承。但是为了满足静态编程语言对多重继承的需要，Java采用了规格的多
重继承，即接口。如果使用接口，即使对没有继承关系的不同种类的对象也可以做共通的处
理。

但是接口只能实现规格的多重继承，实现的多重继承在Java中是不允许的。这种设计原则多
少会让人感觉到不方便吧。

因为不允许实现的多重继承，如果要共通实现的话，一般要像图2-26所示的程序一样使用委
托的方法。图2-27是使用委托来共通实现的Java程序例子。它把从接口调用的方法，都明确
地委托给实现共通功能的对象。本来在多重继承中可以自动实现的，现在要通过手工来实现。
虽然有些麻烦，但这也算Java的风格吧。

图2-28没有用委托的方法，而是把实现共通功能的对象作为成员变量来使用。这样操作对象
并不需要直接实现接口，而只是作为属性保存一个实现共通功能的对象，在程序中直接调用
该属性的方法。

没有了委托的方法，这些部分就变得简单明了，但是在调用共通功能的时候，每次都要引用
属性加上.lock，会让人觉得不怎么漂亮。


本节回顾了多重继承，要点有以下5个。

（1）多重继承并不可怕。

（2）今后面向对象编程语言必须有某种形式的多重继承。

（3）类既有类型的一面又有模块的一面。

（4）C++、Eiffel等语言积极利用了类的模块的一面。

（5)使用Mix-in可以避免多重继承的类关系变复杂。

正确地使用多重继承是提高程序效率的有效方法。如果本节的说明能够减少对多重继承的误
解，那我就感到很幸运了[fn:page391]。

#+BEGIN_SRC org

interface LockingMixin {
  void lock();
  void unlock();
}

class Lock {
  void lock(){……；};
  void unlock(){……；};
}

class Printer implements LockingMixin{
  final Lock lock=new Lock();
  void lock() {lock.lock();}
  void unlock() {lock.lock();}
  void spool(TextData text){
    this.lock();
    ……
    this.unlock();
  }
}

#+END_SRC

图2-27 用委托来实现多重继承的Java程序

#+BEGIN_SRC org

interface LockingMixin {
  void lock();
  void unlock();
}

class Lock implements LockingMixin{
  void lock(){};
  void unlock(){};
}

class Printer{
  final Lock lock=new Lock();
  void spool(TextData text){
    this.lock.lock();
    ……
    this.lock.unlock();
  }
}

#+END_SRC

图2-28 不用委托来实现多重继承的Java程序
*** 2.5 Duck Typeing诞生之前 

在编程世界中，经常提到静态（static)与动态(dynamic)这样的词汇。静态是指程序执行之
前，从代码中就可以知道一切。程序静态的部分包括变量、方法的名称和类型以及控制程序
的结构等等。

相对于静态，动态是指在程序执行之前有些地方是不知道的。程序动态的部分包括变量的值、
执行时间和使用的内存等等。

如果知道育种使用的算法和输入值，虽然有时候不执行也可以知道输出的结果，但是现实中
这种单纯的情况很少。通常情况下，程序本来就是不被执行就不知道结果的，所以从一定程
度上说程序都具有动态特性。因此，严格地说，静态和动态之间的界限是微妙的。
*** 2.5.1 为什么需要类型

在程序中具有动态或静态特性的东西很多，这里以类型为重点，讲解一下静态类型和动态类
型。

编程语言中的类型指的是数据的种类。例如整数和字符串都是数据的类型。从硬件的角度来
看，计算机可以处理的类型只有二进制。在计算机可以直接操作的汇编语言中，数据类型都
是整数[fn:page392]，其他类型的数据都用整数来表现。

例如表现字符串的时候，是给每个字符都编上号，这些整数编号排列起来构成了字符串。内
存中的地址（位置）也是用整数来表现的。数据、对象等复杂数据也是一样的。

但是这种处理方法是很低级的，它要求人要理解、记忆用整数来表达所有类型数据的方法。
不小心出一点关错程序就不能运行。

这样的话程序员的负担就太大了，所以编程语言就进化了。被称为世界上最初的编程语言的
FORTRAN(Formaula Translator,公式变换机),引入了变量和算式的类型。在程序中，变量只
能用整数赋值，数组只能是浮点的数组等，可以指定数据类型。这是静态数据类型的开始。
这种对数据类型的定义称为类型定义。图2-29是C语言的类型定义，它是静态语言的代表。


* Footnotes

[fn:page392] 只处理二进制数的说法只是一个概念。实际上CPU可以直接处理浮点小数等整
数以外的类型。

[fn:page391] 本节内容参考了《面向对象入门》一书，该书由Bertrand Meyer著，二木厚
吉审校，酒顺子译，Ascii出版，ISBN4756100503。书名是“入门”，但根本不是面向初学
者的，而是面向中高级读者的书。例题都是用（大家不太熟悉的）Eiffel语言写成的，遗憾
的是Eiffel本身的版本也很老，但即使有这些缺点，这本书还是非常有价值的。例题以外的
内容一点也不过时。如果想要进一步深入理解面向对象编程的话，这本书可以说是最好的。
还有，翔泳社重新翻译了这本书，分两册出版：《面向对象入门（第2版）：原则.概念》，
《面向对象入门（第2版）：方法论.实践》。

[fn:page352] 组合是把多个对象合成一个对象来处理。委托是把对一个对象的方法调用委
派给别的对象。

[fn:page351] Eiffel是在20世纪80年代后期由Bertrand Meyer设计的面向对象编程语言。
其主要特点是静态类型与多重继承，严密的规格与“基于契约的设计”。Eiffel在国外金融
等领域中得到了实际应用。

[fn:page342] 子类对象拥有父类所有属性，可以当做父类对象来处理，这种状态称为
LSP(Liscov Substitution Principle)。

[fn:b22]b22
  

[fn:a223] a223

[fn:2-1-1] ddd

[fn:1] jddjjd

[fn:no] 厚厚是

[fn:a222]队列是和栈相似的数据结构，是先入先出山的。 

[fn:page21]Ruby也可以用于原型（prototype)面向对象编程 

[fn:page23] 单一继承（single inheritance)是指只能有一个父类（super class)的继承，
也称为单纯继承。有多个父类的继承称为多重继承(multiple inheritance)。

[fn:page28-1]这种宽松的编程机制称为Duck Typeing(鸭子类型检测） 

[fn:page28-2]动态编程语言中，区分规格的继承和实现的继承意义不大。即使没有继承关
系，方法也可以自由地调用。 

[fn:page341] DRY(Don't Repeat Yourself)原则就是彻底避免重复。这一原则对提高程序
开发的效率和可靠性非常有效。

[fn:page3301] 在有些编程语言中，类并不是必需的。相对于基于类的面向对象语言来说，
那些类不是必需的面向对象语言称为基于原型的语言。有代表性的基于原型的语言有
Self.Ajax背后的JavaScript也是基于原型的语言。


[fn:page332] 20世纪70年代，Michael A.Jackson在开发的Jackson Structured
Programming(JSP)中尝试了数据的结构化。但是，JSP中结构化对象是操作数据的流程而不
是数据。

[fn:page331] Edsger Wybe Dijkstra 是荷兰的计算机科学家。他提倡结构化编程，发起了
减少使用goto语法的运动。他也是解决图论中最短路径问题的Dijkstra方法的研究者。


[fn:page322] Mix-in是Ruby中可以利用的一个抽象类。既具有单一继承的方法构成和优先
顺序的明确性，可可以像多重继承一样从多个类继承。Mix-in类不能用来生成实例，也不能
继承普通类。



[fn:page31] 由松本行弘与石冢圭树合著，ASCII出版社出版，ISBN为
4756132545(http://www.ascil.co.books/detail/4-7561/4-7561-3254-5.html）。

[fn:a3] 《设计模式：可复用面向对象软件基础》，Erich Gamma 等著，机械工业出版社出
版。
上一节讲解了面向对象编程的三大原则（多态性、数据抽象和继承）中的继承。如前所述，
人们一次能够把握并记忆的概念是有限的，为解决这一问题，就需要用到抽出类中相似部分
的方法（继承）。继承是随着程序的结构化和抽象化自然进化而来的一种方式。

[fn:a2] Algorithms + Data Structures = Programs, Niklaus Wirth 著。Wirth 是在
1971年开发了 Pascal 编程语言的计算机学者。
但最后一句话严格来说并不完全正确。结构化和抽象化，意味着把共ceep部分提取出来生成
父类的自底向上的方法。如果继承是这样诞生的话，那么最初，有多个父类的多重继
承[fn:page23]就会成为主流。

[fn:a1] 比如 MacOS X10.5中标准搭载了 Ruby 1.8.6。
但实际上，最初引入继承的Simula编程语言，只提供单一继承。同样，在随后的很多面向对
象编程语言中也都是这样的。因此我认为，继承的原本目的实际上是逐步细化。

[fn:no3] 图灵完备指在可计算性理论中，编程语言或任意其他的逻辑系统具有等同于能用
图灵机的计算能力。换言之，此系统可与能用图灵机互相模拟。这个词源于引入图灵机概念
的数学家阿兰.图灵(Alan Turing)。
正如上一节中说明的，如果把继承作为抽离出程序的共通部分的一个抽象化手段来考虑，那
么从一个类中抽象化（抽出）的部分只能有一，这个假定会给编程带来很大的限制。因此，
多重继承的思想就这样产生了。单一继承和多重继承的区别仅仅是父类的数量不同。多重继
承完全是单一继承的超集，可以简单地看做是单一继承的一个自然延伸（图2-13）。

[fn:no2] Paul Graham 目前是世界知名的天使投资人，其公司Y Combinator投资了很多极
有前途的创业项目。Paul Graham曾出版过两本Lisp专著，最新著作《黑客与画家》已经由
人民邮电出版社出版。————编者注
可以使用多重继承的编程语言，不受单一继承的不自然的限制。例如，只提供单一继承的
Smalltalk语言，它的类库因为单一继承而显得很不自然。
[[/Users/mac/Desktop/ruby p/图2-13.png]]
